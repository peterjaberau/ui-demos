import{r as i}from"./index-2c36b58a.js";const j=window.__pendingRequests=[];function A({pageSize:a=25,timeout:l=1e3,randomErrors:f=!1}){const[u,d]=i.useState(new Array),o=i.useRef(u),m=e=>{d(t=>{const s=e(t);return o.current=s,s})},[p,h]=i.useState("pending"),[q,w]=i.useState(""),c=i.useRef(new Array);function x(){c.current.forEach(e=>e.cancelled=!0),c.current=[]}function v(){return c.current.some(e=>!e.resolved&&!e.rejected)}function P(){const e=c.current.filter(s=>s.resolved),t=e[e.length-1];return t?t.pageNumber+1:0}function S(e,t){return new R(e,(s,r)=>setTimeout(()=>{if(f&&Math.random()<.3)r();else{const n=t.slice(e*a,(e+1)*a);s({items:n,hasNextPage:o.current.length+n.length<t.length})}},l))}function I(e,t){const s={filteringText:t,pageNumber:e};return new R(e,(r,n)=>j.push({resolve:r,reject:n,params:s}))}function N({sourceItems:e,firstPage:t,filteringText:s}){if(t&&(m(()=>[]),w(s),x()),v())return;h("loading");const r=P(),n=e?S(r,e):I(r,s);c.current.push(n),n.promise.then(g=>{n.cancelled||(m(T=>[...T,...g.items]),h(g.hasNextPage?"pending":"finished"))}).catch(()=>{h("error")})}return{items:u,status:p,filteringText:q,fetchItems:N}}class R{constructor(l,f){this.cancelled=!1,this.resolved=!1,this.rejected=!1,this.pageNumber=l,this.promise=new Promise((u,d)=>{this.cancelled||f(o=>{this.resolved=!0,u(o)},()=>{this.rejected=!0,d()})})}}export{A as u};
